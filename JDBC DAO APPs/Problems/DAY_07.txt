--inter thread communication: (Thead synchronization)
--------------------------------------

--wait and notify method, these methods belongs to Object class.

--since these methods belongs to Object class, we can call these methods on 
any object.

--that method call should be inside the synchronized area. that means on which
object we call wait and notify method, the thread should have lock of that object.

producer and consumer problem:
===========================

Common.java:
------------------

package com.masai;

public class Common {
	
	
	int value;
	
	boolean flag = true;
	
	public synchronized void produce(int i) {
		
		if(flag == true) {
		
		value= i;
		System.out.println("Producer produces :"+i);
		flag = false;
		this.notify();
		
		try {
			this.wait();
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		}
	
	}
	
	public synchronized int consume() {
	
		if(flag == true) {
			
			try {
				this.wait();
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		
		flag = true;
		this.notify();
		

		return value;
	
	
	}
}


ProducerThread.java:
---------------------------

package com.masai;

public class ProducerThread extends Thread{
	
	Common c;
	
	public ProducerThread(Common c) {
		this.c=c;
	}
	
	
	@Override
	public void run() {
	
		int i=0;
		
		while(true) {
			
			c.produce(i);
			i= i+1;	
			
			try {
				Thread.sleep(1000);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		
		
		
	}
	

}



ConsumerThread.java:
-----------------------------

package com.masai;

public class ConsumerThread extends Thread{
	
	Common c;
	
	public ConsumerThread(Common c) {
		this.c=c;
	}
	
	@Override
	public void run() {
	
		while(true) {
			
			int i= c.consume();
			System.out.println("Consumer consume :"+i);
			
			try {
				Thread.sleep(1000);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			
		}
	
	}

}



Demo.java:
--------------

package com.masai;

public class Demo {
	
	public static void main(String[] args) {
		
		Common c= new Common();
		
		ProducerThread pr = new ProducerThread(c);
		
		ConsumerThread cr= new ConsumerThread(c);
		
		pr.start();
		cr.start();
			
	}
}


Deadlock example:
-----------------------

A.java:
----------

package com.masai;

public class A {
	
	public synchronized void funA(B b1) {
		
		System.out.println("Thread t1 accquires the lock of a1");
		System.out.println("funA of A starts");
		
		System.out.println("Thread t1 needs the lock of b1 to call fun2");
		b1.fun2();
		
		System.out.println("funA of A ends");
	}
	
	public synchronized void fun1() {
		
		System.out.println("inside fun1 of A");
	}

}


B.java:
---------

package com.masai;

public class B {
	
	public synchronized void funB(A a1) {
		
		System.out.println("Thread t2 accquirs the lock of b1");
		System.out.println("funB of B starts");
		
		System.out.println("Thread t2 needs the lock of a1 to call the fun1");
		a1.fun1();
		
		System.out.println("funB of B ends");
	}
	
	public synchronized void fun2() {
		
		System.out.println("inside fun2 of B");
	}

}


ThreadA.java:
----------------
package com.masai;

public class ThreadA extends Thread{

	A a1;
	B b1;
	
	public ThreadA(A a1, B b1) {
		this.a1=a1;
		this.b1=b1;
	}
	
	@Override
	public void run() {
	
			a1.funA(b1);
	
	}
		
}


ThreadB.java:
-------------------

package com.masai;

public class ThreadB extends Thread{

	A a1;
	B b1;
	
	public ThreadB(A a1, B b1) {
		this.a1=a1;
		this.b1=b1;
	}
	
	@Override
	public void run() {
	
			b1.funB(a1);
	
	}
	
	
	
}


Demo.java:
-----------------
package com.masai;

public class Demo {
	
	public static void main(String[] args) {
		
		A a1= new A();
		B b1= new B();
		
		ThreadA ta=new ThreadA(a1, b1);
		ThreadB tb= new ThreadB(a1, b1);
		
		ta.start();
		
		tb.start();
		
		
	}

}

Executor framework: ThreadPool:
==========================

similarities bt Runnable and Callable:
-----------------------------------------------

1. both is used to define the task of a thread.
2. both is a functional interface, i.e both is having only one method.


Demo.java:
--------------

package com.masai;

import java.io.File;
import java.io.IOException;

public class Demo {
	
	public static void main(String[] args) {
		
		File f= new File("d://a1.txt");
		
		
		try {
			boolean	flag = f.createNewFile();
		
			System.out.println("File created.."+flag);//
		
		} catch (IOException e) {
			
			System.out.println(e.getMessage());
		}
		
	}

}



File class constructors:

File f = new File(String fname); //we can provide relative of absolute path.

File f=new File(String subdir,String fname);

File f =new File(File subdir,String fname);



Getting all the files from a directory recursivly:
--------------------------------------------------------

package com.masai;

import java.io.File;
import java.io.IOException;

public class Demo {
	
	public static void readFiles(File f) {
		
		
		File[] files= f.listFiles();
		
		for(File file:files) {
			if(file.isFile())
				System.out.println(file.getName());
			else
				readFiles(file);
		}
		
		
		
	}
	
	
	public static void main(String[] args) throws IOException {
		
		File rootFile = new File("d://abc");
		
		readFiles(rootFile);
		
		
	}

}










































